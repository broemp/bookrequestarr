# Automatic Database Initialization

## Overview

Bookrequestarr now automatically creates the database and applies all migrations on startup. This eliminates the need for manual database setup steps and makes deployment simpler.

## How It Works

### Initialization Process

When the application starts, it automatically:

1. **Checks if the database file exists**
   - If not, creates the database directory and file

2. **Verifies migrations are available**
   - Looks for migration files in the `drizzle/` directory
   - Logs a warning if no migrations are found

3. **Applies pending migrations**
   - Runs all pending migrations automatically
   - Uses Drizzle ORM's built-in migration system
   - Ensures migrations are idempotent (safe to run multiple times)

4. **Logs the results**
   - Success: "Database created and migrations applied successfully"
   - Or: "Database migrations applied successfully"
   - Errors are logged with full context

### Implementation Details

The automatic initialization is implemented in two files:

#### `/src/lib/server/db/migrate.ts`

This module contains the core initialization logic:

- `ensureDatabaseDirectory()` - Creates the database directory if needed
- `databaseExists()` - Checks if the database file exists
- `hasMigrations()` - Verifies migration files are available
- `initializeDatabase()` - Main function that orchestrates the initialization

#### `/src/lib/server/db/index.ts`

The database connection module now:

- Calls `initializeDatabase()` on module load
- Uses a promise-based initialization pattern to prevent race conditions
- Exits the process if initialization fails (fail-fast approach)

## Benefits

### For Users

- **Zero-configuration database setup** - Just start the app
- **No manual migration steps** - Everything happens automatically
- **Consistent deployment** - Works the same in development and production
- **Docker-friendly** - Perfect for containerized deployments

### For Developers

- **Faster onboarding** - New developers can start immediately
- **Less documentation** - No need to explain database setup
- **Fewer errors** - Can't forget to run migrations
- **Better DX** - One command to start developing

## Usage

### First-Time Setup

Simply start the application:

```bash
npm run dev
```

Or with Docker:

```bash
docker compose up -d
```

The database will be created automatically in the location specified by `DATABASE_URL`.

### After Schema Changes

1. Generate a new migration:

   ```bash
   npm run db:generate
   ```

2. Restart the application:
   ```bash
   npm run dev
   ```

The new migration will be applied automatically on startup.

### Manual Migration (Optional)

If you prefer to apply migrations manually (e.g., for testing):

```bash
npm run db:migrate
```

This is now optional - the application will apply migrations on next startup anyway.

## Configuration

### Environment Variables

- `DATABASE_URL` - Path to the SQLite database file (required)
  - Example: `./data/bookrequestarr.db`
  - The directory will be created if it doesn't exist

### Migration Files

Migrations are stored in the `drizzle/` directory:

```
drizzle/
├── 0000_regular_blade.sql
├── 0001_bouncy_blindfold.sql
├── 0002_melted_santa_claus.sql
└── meta/
    └── _journal.json
```

These files are generated by Drizzle Kit and should be committed to version control.

## Logging

The initialization process logs important events:

```
[INFO] Database file not found, creating new database
[INFO] Creating database directory: ./data
[INFO] Running database migrations...
[INFO] Database created and migrations applied successfully
[INFO] Database initialization complete
```

Or for existing databases:

```
[INFO] Database file found, checking for pending migrations
[INFO] Running database migrations...
[INFO] Database migrations applied successfully
[INFO] Database initialization complete
```

## Error Handling

### Initialization Failures

If initialization fails, the application will:

1. Log the error with full context
2. Exit with a non-zero status code
3. Prevent the application from starting in an inconsistent state

Example error log:

```
[ERROR] Failed to run database migrations {
  error: "SQLITE_ERROR: near \"CREAT\": syntax error",
  stack: "..."
}
[ERROR] Critical: Database initialization failed on startup
```

### Common Issues

#### Database Directory Not Writable

**Error:** `EACCES: permission denied`

**Solution:** Ensure the application has write permissions to the database directory:

```bash
chmod 755 data/
```

#### Database File Locked

**Error:** `SQLITE_BUSY: database is locked`

**Solution:** Ensure no other processes are accessing the database:

```bash
# Find processes using the database
lsof data/bookrequestarr.db

# Stop other instances
docker compose down
```

#### Migration File Corruption

**Error:** `SQLITE_ERROR: near "...": syntax error`

**Solution:** Check the migration files in `drizzle/` for corruption. Regenerate if needed:

```bash
# Backup existing database
cp data/bookrequestarr.db data/bookrequestarr.db.backup

# Regenerate migrations
npm run db:generate
```

## Migration Strategy

### Development

During development, migrations are applied automatically on every restart. This ensures your local database is always up-to-date with the schema.

### Production

In production, the same automatic migration applies:

1. Deploy new version with updated migrations
2. Application starts and applies pending migrations
3. Application becomes available with updated schema

**Important:** Always test migrations in a staging environment first!

### Rollback Strategy

If a migration fails in production:

1. The application will exit immediately
2. The database remains in its previous state (SQLite transactions)
3. Fix the migration and redeploy
4. Or restore from backup if needed

## Best Practices

### 1. Always Generate Migrations

Never modify the database schema directly. Always use:

```bash
npm run db:generate
```

This ensures migrations are tracked and can be applied consistently.

### 2. Test Migrations

Before deploying, test migrations on a copy of production data:

```bash
# Copy production database
cp production.db test.db

# Test migration
DATABASE_URL=test.db npm run dev
```

### 3. Keep Migrations Small

Create focused migrations that do one thing. This makes them easier to review and rollback if needed.

### 4. Commit Migration Files

Always commit generated migration files to version control:

```bash
git add drizzle/
git commit -m "Add migration for new feature"
```

### 5. Monitor Startup Logs

In production, monitor startup logs to ensure migrations are applied successfully:

```bash
docker compose logs -f bookrequestarr | grep -i migration
```

## Troubleshooting

### Migration Not Applied

**Symptom:** Schema changes not reflected in database

**Check:**

1. Is the migration file in `drizzle/`?
2. Did you restart the application?
3. Check startup logs for errors

### Slow Startup

**Symptom:** Application takes a long time to start

**Possible causes:**

- Large database requiring schema changes
- Network storage (use local storage for SQLite)
- Multiple migrations being applied

**Solution:** This is normal for first-time setup or after many schema changes.

### Database Corruption

**Symptom:** `SQLITE_CORRUPT: database disk image is malformed`

**Solution:**

1. Restore from backup
2. Or try SQLite recovery:
   ```bash
   sqlite3 data/bookrequestarr.db ".recover" | sqlite3 data/recovered.db
   ```

## Technical Details

### Concurrency Safety

The initialization uses a promise-based pattern to ensure:

- Only one initialization runs at a time
- Concurrent database access waits for initialization to complete
- No race conditions during startup

### Migration Tracking

Drizzle ORM tracks applied migrations in a special table:

```sql
CREATE TABLE __drizzle_migrations (
  id INTEGER PRIMARY KEY,
  hash TEXT NOT NULL,
  created_at INTEGER NOT NULL
);
```

This ensures migrations are only applied once.

### Performance Impact

- **First startup:** ~100-500ms (depending on number of migrations)
- **Subsequent startups:** ~50-100ms (just checking for pending migrations)
- **No migrations pending:** ~10-20ms (quick check)

The impact is minimal and only occurs during application startup.

## Future Enhancements

Potential improvements for the future:

- [ ] Migration dry-run mode
- [ ] Automatic backup before migrations
- [ ] Migration rollback support
- [ ] Health check endpoint for migration status
- [ ] Prometheus metrics for migration timing
- [ ] Support for PostgreSQL/MySQL (when needed)

## See Also

- [Development Guide](DEVELOPMENT.md) - Local development workflow
- [Deployment Guide](DEPLOYMENT.md) - Production deployment
- [Configuration Guide](CONFIGURATION.md) - Environment variables
